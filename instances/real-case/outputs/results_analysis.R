#--------------------------------------------------------------------------
# Script for exploratory and statistical analysis of data from 
# manuscript: Multi-objective matheuristic for minimization of total 
# tardiness and energy costs in a steel industry heat treatment line
#--------------------------------------------------------------------------


# Environment initialization ----------------------------------------------

# Clear console and variables
cat("\014")  
rm(list=ls())

# Install packages
library(dplyr)    # Transform data frame
library(tidyr)    # Separate function
library(multcomp) # Tukey´s test
library(car)      # Durbin Watson test
library(ggplot2)  # GGplot2 for boxplot chart
library(ggpubr)   # Publication ready plots

# Load experimental data --------------------------------------------------

# Load data
files <- list.files("data-csv", pattern="*.csv", full.names = T)
data <- do.call(rbind,
                lapply(files,
                       function(i){read.csv(i,sep=";")}))

# Aggregate data
aggdata <- with(data, aggregate(x = list(RunTimeSec, Hipervolume, NumParetoSolutions),
                                by = list(InitialMethod, Instance),
                                FUN = mean))

# Rename columns and coerce factor variables
names(aggdata) <- c("InitialMethod", 
                    "Instance", 
                    "Runtime", 
                    "Hipervolume", 
                    "NumSolutions")
aggdata[,1] <- as.factor(aggdata[,1])


# Exploratory analysis of matheuristic first step -------------------------

# Group data from matheuristic execution - Initial solutions generated by MILP
data.matheuristic <- data %>%
  filter(InitialMethod=="MILP")

# Get maximum hypervolume calculated per instance
data.matheuristic.maxhyp <- data.matheuristic %>%
  group_by(Instance) %>%
  summarise(Hipervolume = max(Hipervolume))

# Get all records with maximum hypervolume per instance
data.matheuristic.bestexec <- merge(data.matheuristic.maxhyp, 
                                    data.matheuristic)

# Transform the data to generate manuscript table
data.matheuristic.bestexec <- data.matheuristic.bestexec %>%
  separate(Instance, c("Instance", "NumJobs"), "_") %>%
  transform(NumJobs = as.numeric(NumJobs)) %>%
  mutate("RunTimeMin"=round((RunTimeSec/60),digits=2)) %>%
  mutate_if(is.numeric, round, 2) %>%
  mutate_at(vars(starts_with("Gap")), function(i){i*100}) %>%
  group_by(Instance) %>% 
  filter(row_number()==1) %>%
  arrange(NumJobs, .by_group=FALSE)

# Table with data from MILP runs to define initial solutions 
table.MILP <- data.matheuristic.bestexec[,c("Instance", 
                                            "NumJobs", 
                                            "NumGroupsTEC", 
                                            "TimeTEC", 
                                            "GapTEC", 
                                            "NumGroupsTT", 
                                            "TimeTT", 
                                            "GapTT", 
                                            "TimeTT_TEC", 
                                            "GapTT_TEC")]

# Boxplot for comparison of proposed matheuristic and simple MOVNS
boxplot.data <- data %>%
  separate(Instance, c("InstanceNum", "NumJobs"), "_") %>%
  separate(InstanceNum, c("Prefix", "Instance"), "instance")
boxplot.data$Instance <- as.numeric(boxplot.data$Instance)

ggplot(boxplot.data, aes(x=InitialMethod, y=Hipervolume, fill=InitialMethod)) +
  geom_boxplot() +
  facet_wrap(~Instance, scales="free", nrow=3, labeller=label_both) +
  labs(y="Hypervolume") +
  theme_bw() +
  scale_fill_brewer(palette="Set1")

# Statistical Analysis - Proposed Matheuristic vs Simple MOGVNS -----------

# Paired Test
# H0 -> difference in means of proposed matheuristic and simple MOGVNS hypervolumes is equal to 0
t.test(Hipervolume~InitialMethod,
       paired=T,
       data=aggdata,
       alternative="less")

# Tukey´s test
anova.model.hipervolume <- aov(Hipervolume~InitialMethod+Instance, 
                               data=aggdata)
summary(anova.model.hipervolume)
par(mar=c(5,11,2,2))
plot(confint(glht(anova.model.hipervolume, 
                  linfct = mcp(InitialMethod = "Tukey")), 
             level = 0.95), 
     xlab="Hypervolume",
     cex.lab=0.9, 
     cex.axis=0.9, 
     las=1.5)

# Verify data assumptions for statistical tests
# Normality of the residuals
shapiro.test(anova.model.hipervolume$residuals)
# Equality of variance of the residuals
fligner.test(Hipervolume~InitialMethod, 
             data = aggdata)
# Independence of the residuals
durbinWatsonTest(anova.model.hipervolume)


# Exploratory analysis of matheuristic final results ----------------------

# Get objectives values from extreme solutions of final approximated Pareto fronts
costFunctions <- data.matheuristic.bestexec$CostFunctions
data.matheuristic.objectives <- by(data.frame(costFunctions), 
                                   1:nrow(data.frame(costFunctions)), 
                                   function(row) {
  i <- 1
  tt_row <- c()
  tec_row <- c()
  points <- strsplit(as.character(row$costFunctions), "|", fixed=T)
  for(point in points[[1]]) {
    if(!is.na(point)) {
      objs <- strsplit(as.character(point), " ", fixed=T)
      tt_row[i] <- as.numeric(objs[[1]][1])
      tec_row[i] <- as.numeric(objs[[1]][2])
      i = i + 1
    }
  }
  result <- c(0,0,0,0)
  names(result) <- c("TT_MAX","TT_MIN","TEC_MAX","TEC_MIN")
  result[1] <- max(tt_row)
  result[2] <- min(tt_row)
  result[3] <- max(tec_row)
  result[4] <- min(tec_row)
  return(result)
})
data.matheuristic.objectives <- data.frame(t(sapply(data.matheuristic.objectives,c)))

# Get objectives values from real sequence executed by the company
realCostFunctions <- data.matheuristic.bestexec$RealSolution
data.matheuristic.realObjectives <- by(data.frame(realCostFunctions), 
                                       1:nrow(data.frame(realCostFunctions)), 
                                       function(row) {
  result <- c(0,0)
  names(result) <- c("TT_REAL","TEC_REAL")
  objs <- strsplit(as.character(row$realCostFunctions), " ", fixed=T)
  result[1] <- as.numeric(objs[[1]][1])
  result[2] <- as.numeric(objs[[1]][2])
  return(result)
})
data.matheuristic.realObjectives <- data.frame(t(sapply(data.matheuristic.realObjectives,c)))

# Table with final results from proposed matheuristic
table.MATHEURISTIC <- data.matheuristic.bestexec[,c("Instance", 
                                                    "NumJobs", 
                                                    "RunTimeMin", 
                                                    "NumParetoSolutions")]
table.MATHEURISTIC$TEC_REAL <- data.matheuristic.realObjectives$TEC_REAL
table.MATHEURISTIC$TEC_MIN <- data.matheuristic.objectives$TEC_MIN
table.MATHEURISTIC$TEC_MAX <- data.matheuristic.objectives$TEC_MAX
table.MATHEURISTIC$TT_REAL <- data.matheuristic.realObjectives$TT_REAL
table.MATHEURISTIC$TT_MIN <- data.matheuristic.objectives$TT_MIN
table.MATHEURISTIC$TT_MAX <- data.matheuristic.objectives$TT_MAX
table.MATHEURISTIC$PI_TEC_MAX <- round((1 - (data.matheuristic.objectives$TEC_MIN/data.matheuristic.realObjectives$TEC_REAL))*100,1)
table.MATHEURISTIC$PI_TT_MAX <- round((1 - (data.matheuristic.objectives$TT_MIN/data.matheuristic.realObjectives$TT_REAL))*100,1)

# Boxplot for PI_TEC_MAX
boxplot(table.MATHEURISTIC$PI_TEC_MAX,
        xlab="PI_TEC_MAX", ylab="%")

# Boxplot for PI_TT_MAX
boxplot(table.MATHEURISTIC$PI_TT_MAX,
        xlab="PI_TT_MAX", ylab="%")

# Average values for PI
mean(table.MATHEURISTIC$PI_TEC_MAX)
median(table.MATHEURISTIC$PI_TT_MAX, na.rm = TRUE)

